%!TEX root=../mythesis.tex
% Chapter 1

\chapter{Introduction} % Main chapter title
\chaptermark{Introduction}
\label{ch:introduction}

\section{Motivation}\label{sec:motivation}
In the context of rapid digital transformation and the accelerated advancedment of Artificial Intelligence (AI), software systems have evoloved from relatively static artifacts into dynamic entities capable of continuously adapting to changing requirements. To remain effective in the face of evolving requirements, technological innovations, and emerging security threats, ongoing modification and extension, collectively known as software evolution, have become an inherent and unavoidable characteristic of modern software engineering. Broadly, software evolution is primarily driven by two forces: \textbf{external adaptation}, which responds to changes in the third-party ecosystem, and \textbf{internal improvement}, which systematically modify code and update corresponding documentation to satisfy new functional and quality requirements.

In recent years, the deep integration of AI, especially Large Language Models (LLMs), into the software development lifecycle has signaled a significant paradigm shift in software evolution. Empowered by advances in artificial intelligence, intelligent development tools and autonomous agents are increasingly capable of understanding and processing large-scale codebases alongside natural language requirements, while progressively demonstrating higher-level reasoning abilities such as cross-context analysis and complicated problem decomposition. Leveraging these capabilities, AI systems can automate a wide range of labor-intensive and high-complexity tasks, such as code generation, bug fixing, documentation synchronization, and system maintenance, thereby reshaping critical stages of software evolution and enabling complex software systems to achieve continuous iteration and scalable growth at unprecedented speed. Meanwhile, this AI-driven development paradigm introduce new technical pathways for managing long-term software evolution, propelling software engineering beyond human-centered development model toward a new stage characterized by the coexistence of human–AI collaboration and autonomous intelligent.

Despite these advances, the application of LLMs in software evolution remains fundamentally constrained by their probabilistic generative nature. Although large-scale parameterization facilitates the emergence of complex reasoning capabilities, LLMs generate outputs based on learned statistical patterns rather than deterministic logic, making it a probabilistic mirage that lacks the deterministic guarantees required for absolute reliability. At the same time, modern software systems have evolved into highly interconnected dependency networks: a project is not only an internal system but also a third-party library for other projects. Allowing AI agents to arbitrarily modify code and documentation is highly risky, may inadvertently introduce new vulnerabilities or disrupt existing functionalities. In this context, even seemingly minor modifications, such as a library upgrade or internal refactoring, can propagate cascading effects that compromise system reliability, security, and maintainability at scale. 

Consequently, ensuring the reliability and robustness throughout AI-assisted software evolution can be distilled into three interrelated core challenges:

\begin{itemize}
  \item \textbf{How to handle external ecosystem changes?} The lack of high-quality, real-world benchmark data that captures intricate patterns of breaking changes caused by third-party library upgrades limits AI’s ability to understand and solve external dependency risks.
  \item \textbf{How to preserve internal semantic consistency?} Code and documentation are often updated asynchronously. Since a project simultaneously functions as a third-party dependency for others, its documentation forms the outward semantic interface; internal inconsistencies therefore directly amplify external usage risks.
  \item \textbf{How to perform intelligent code modification?} Accurate code localization is the prerequisite for all automated modification tasks. However, existing LLM-driven approaches still rely heavily on superficial textual cues rather than deep semantic and logical reasoning over program structure, leading to imprecise identification of modification scopes and degraded evolution quality. 
\end{itemize}

These three challenges correspond respectively to external adaptation, internal consistency, and reliable execution of evolution, together forming the central bottleneck in AI-enabled software evolution and providing the systematic research motivation and theoretical foundation for this dissertation.

\section{Contributions}\label{sec:contribution}

\begin{figure}[htbp]

\begin{tikzpicture}[
    node distance = 1.5cm and 0.2em,
    chapter_node/.style = {
        align=center,
        font=\sffamily\small,
        % text width=0.28\textwidth,
        inner sep=2pt,
    },
    arrow/.style = {
        -{Stealth[scale=1.2]},
        thin
    }
]

    \node[chapter_node] (c1) {
        \textcolor{blue}{\underline{\textbf{Chapter 1}}} \\ 
        Introduction
    };

    \node[chapter_node, below=of c1] (c2) {
        \textcolor{blue}{\underline{\textbf{Chapter 2}}} \\
        Background and Literature Review
    };

    \node[chapter_node, below=1.5cm of c2] (c4) {
        \textcolor{blue}{\underline{\textbf{Chapter 4}}} \\
        \textbf{\textsc{MPChecker}:} Multi-parameter \\ 
        Code-Doc Inconsistency Detection\\ 
        \textcolor{blue}{$\bullet$ new approach}
    };

    \node[chapter_node, left= of c4] (c3) {
        \textcolor{blue}{\underline{\textbf{Chapter 3}}} \\
        \textbf{\textsc{CompSuite}:} A Dataset of Lib-\\ 
        rary Upgrade Incompatibilities\\
        \textcolor{blue}{$\bullet$ new dataset}
    };

    \node[chapter_node, right= of c4] (c5) {
        \textcolor{blue}{\underline{\textbf{Chapter 5}}} \\
        \textbf{\textsc{DataLoc}:} Neurosymbolic \\ 
        Repo-level Code Localization\\ 
        \textcolor{blue}{$\bullet$ findings \& new approach}
    };

    \node[chapter_node, below=1.5cm of c4] (c6) {
        \textcolor{blue}{\underline{\textbf{Chapter 6}}} \\
        Conclusion and Future Work
    };

    \draw[arrow] (c1.south) -- (c2.north);

    \coordinate (split) at ($(c2.south)!0.3!(c4.north)$);
    \draw (c2.south) -- (split); 

    \draw[arrow] (split) .. controls ++(0,-1.2) and ++(0,1.2) .. (c3.north);
    \draw[arrow] (split) -- (c4.north);
    \draw[arrow] (split) .. controls ++(0,-1.2) and ++(0,1.2) .. (c5.north);

    \coordinate (merge) at ($(c4.south)!0.7!(c6.north)$);

    \draw[arrow] (merge) -- (c6.north); 
    \draw (c3.south) .. controls ++(0,-1.2) and ++(0,1.2) .. (merge);
    \draw (c4.south) -- (merge);
    \draw (c5.south) .. controls ++(0,-1.2) and ++(0,1.2) .. (merge);

\end{tikzpicture}
\caption{The Structure of the Thesis}\label{fig:thesis_structure}
\end{figure}



\section{Organization}\label{sec:organization}


